% Copyright 2022 Edoardo Riggio

% Licensed under the Apache License, Version 2.0 (the "License");
% you may not use this file except in compliance with the License.
% You may obtain a copy of the License at

% 	http://www.apache.org/licenses/LICENSE-2.0

% Unless required by applicable law or agreed to in writing, software
% distributed under the License is distributed on an "AS IS" BASIS,
% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
% See the License for the specific language governing permissions and
% limitations under the License.

\documentclass{article}

\usepackage{hyperref, amsmath, graphicx, amssymb, csquotes, tabularx}
\usepackage{fancyvrb,newverbs,xcolor}

\graphicspath{ {./assets/} }

\definecolor{cverbbg}{gray}{0.93}

\newenvironment{cverbatim}
 {\SaveVerbatim{cverb}}
 {\endSaveVerbatim
  \flushleft\fboxrule=0pt\fboxsep=.5em
  \colorbox{cverbbg}{\BUseVerbatim{cverb}}%
  \endflushleft
}

\newenvironment{lcverbatim}
 {\SaveVerbatim{cverb}}
 {\endSaveVerbatim
  \flushleft\fboxrule=0pt\fboxsep=.5em
  \colorbox{cverbbg}{%
    \makebox[\dimexpr\linewidth-2\fboxsep][l]{\BUseVerbatim{cverb}}%
  }
  \endflushleft
}

\newcommand{\ctexttt}[1]{\colorbox{cverbbg}{\texttt{#1}}}
\newverbcommand{\cverb}
  {\setbox\verbbox\hbox\bgroup}
  {\egroup\colorbox{cverbbg}{\box\verbbox}}

\begin{document}
\begin{titlepage}
    \begin{center}
        \vspace*{1cm}
        
        \Huge
        \textbf{Distributed Systems Cheatsheet}
        
        \vspace{0.5cm}
        \LARGE
        
        \vspace{.5cm}
        
        Edoardo Riggio
   		  \vspace{1.5cm}
       
        \vfill
        
        \today
        
        \vspace{.8cm}
          \Large
          Distributed Systems - S.A. 2022 \\
        Software and Data Engineering \\
        Universit\`{a} della Svizzera Italiana, Lugano \\
        
    \end{center}
\end{titlepage}

\tableofcontents

\newpage

\section{Introduction}
With the advent in the mid 1980's of 16-, 32-, and 64-bit CPUs -- as well as the invention of high-speed computer networks, made it possible for the creation of large numbers of geographically-dispersed networks of computers. These are known as \textbf{distributed systems}.

\subsection{Definition}
A distributed system is a collection of independent computers that appear to the user as a single coherent system. \\ \\
Each computing element of these massive systems are able to behave independently from one another. A computing element is often referred to as a \textbf{node}. This node can either be a hardware device or a software process.

\subsection{Consequences}
Some of the main negative consequences that arise when dealing with distributed systems are the following:

\begin{itemize}
	\item \textbf{Concurrency} \\
	This happens when several processes try to read and write on a shared storage service.
	
	\item \textbf{Absence of a global clock} \\
	Each node will have its own notion of time. This means that there is no common reference of time between the nodes.
	
	\item \textbf{Failure independency}
	The failure of a node can make another node unusable.
	
\end{itemize}

\subsection{Challenges}
Some of the challenges that arise when dealing with distributed systems are outlined in the following sections.

\subsubsection{Openness}
The services are offered according to standard rules. These rules describe both the syntax and semantics of such services. The standard rules of distributed systems are called \textbf{COBRA}(Common Object Request Broker Architecture).

\subsubsection{Scalability}
Scalability can be with respect to the \textbf{system size} -- which would mean adding more users to the system; to the \textbf{geography} -- which would deal with users lying far apart from one another; and to \textbf{administration} -- which would deal with the complexity to manage an increasing system. \\ \\
Some scalability techniques are the following:

\begin{itemize}
	\item \textbf{Hiding communication latencies} \\
	This is important for \textbf{geographical scalability}. Asynchronous communications can be used to reduce the waiting time of the users. This can be achieved with the use of batch processing and parallel applications.
	
	\item \textbf{Distribution} \\
	Components are split into parts and spread across the system. An example of this would be the DNS, where we have a tree of domains divided into non-overlapping zones. Furthermore, the name in a zone is handled by a single name service.
	
	\item \textbf{Replication} \\
	This can be use to increase both \textbf{availability} and \textbf{performance}, as well as reduce \textbf{latency}. Moreover, caching can be used as a form of replication, but is typically done on-demand.
\end{itemize}

\subsubsection{Transparency}
Transparency is the ability of a system to hide some of its characteristics or errors to the user. There exist several different forms of transparency:

\begin{itemize}
	\item \textbf{Access transparency} \\
	Hide the differences in data representation and machine architecture.
	
	\item \textbf{Location transparency} \\
	Users cannot tell where a resource is physically located.
	
	\item \textbf{Relocation transparency} \\
	Even if the entire service was moved from one data center to the other, the user wouldn't be able to tell.
	
	\item \textbf{Migration transparency} \\
	Moving processes and resources initiated by users, without affecting any ongoing communication and operation.
	
	\item \textbf{Replication transparency} \\
	Hide the existence of multiple replicas of one resource.
	
	\item \textbf{Concurrency transparency} \\
	Each user is not going to notice if another user is making use of the same resource.
	
	\item \textbf{Failure transparency} \\
	The user or application does not notice that some piece of the system fails to work properly. The system is then able to automatically recover from the failure.
\end{itemize}

\subsection{Types of Distributed Systems}
There are three main types of distributed systems: \textbf{distributed computing systems}, \textbf{distributed information systems}, and \textbf{distributed pervasive systems}.

\subsubsection{Distributed Computing Systems}
These systems aim at high-performance computing tasks. These systems can be part of two subtypes:

\begin{itemize}
	\item \textbf{Cluster Computing} \\
	All the resourced are located in a local-area network, and are using the same OS. In addition, they also have a common administrative domain.
	
	\item \textbf{Grid Computing} \\
	This is a "federation" of computer systems. Such systems may have different administrative domains, different hardware, software... Such systems are used to make collaboration between organisations feasible.
\end{itemize}

\subsubsection{Distributed Information Systems}
These systems are based on transactions. These transactions are used to make systems communicate between themselves. Transactions follow the \textbf{ACID} properties:

\begin{itemize}
	\item \textbf{Availability} \\
	To the user, the transaction happens indivisibly.
	
	\item \textbf{Consistency} \\
	The transaction does not violate system invariants.
	
	\item \textbf{Isolation} \\
	Concurrent transactions do not interfere with each other.
	
	\item \textbf{Durability} \\
	Once a transaction commits, the changes are permanent.
\end{itemize}

\noindent The application components of each node communicate directly with each other.

\subsubsection{Distributed Pervasive Systems}
These systems are composed by mobile and embedded computing devices. This means that pervasive systems need to have the following characteristics:

\begin{itemize}
	\item Embrace contextual changes
	\item Encourage ad-hoc composition
	\item Recognise sharing as the default
\end{itemize}

\noindent Some examples of such architectures are home systems, electronic health care systems, and sensor networks.

\section{Architectures}
In a distributed system there are two types of architectures:

\begin{itemize}
	\item \textbf{Software Architectures} \\
	How software components are organised and interact between each other.
	
	\item \textbf{System Architectures} \\
	How software components are instantiated on real machines.
\end{itemize}

\subsection{Software Architectures}
Software architectures are based on \textbf{components}, which are modular units with well-defined interfaces. Software architectures can be of several different types:

\begin{itemize}
	\item \textbf{Layered architectures}
	\item \textbf{Object-based architectures}
	\item \textbf{Data-centred architectures}
	\item \textbf{Event-based architectures}
\end{itemize}

\subsubsection{Layered Architectures}
In this kind of architecture, the components at layer $L_i$ can call components in layer $L_{i-1}$, but not components in layer $L_{i+1}$.

\begin{center}
	\includegraphics[width=7cm, height=5cm, keepaspectratio]{assets/layered.pdf}
\end{center}

\subsubsection{Object-Based Architectures}
Each object is a component connected through a remote procedure call mechanism.

\begin{center}
	\includegraphics[width=11cm, height=5cm, keepaspectratio]{assets/object-based.pdf}
\end{center}

\subsubsection{Data-Centred Architectures}
The processes communicate through a common repository. This repository can be, for example, a shared distributed file system or a database.

\begin{center}
	\includegraphics[width=8cm, height=5cm, keepaspectratio]{assets/data-centered.pdf}
\end{center}

\subsubsection{Event-Based Architectures}
The processes communicate through the propagation of events (\textbf{publish-subscribe system}). The middleware ensures that the process which subscribes to that events will receive them. \\ \\
Processes are loosely coupled, this means that they do not to refer to each other.

\begin{center}
	\includegraphics[width=9cm, height=5cm, keepaspectratio]{assets/event-based.pdf}
\end{center}

\subsubsection{Shared Data-Space Architecture}
These architectures are similar to data-centred and event-based architectures.

\begin{center}
	\includegraphics[width=8cm, height=5cm, keepaspectratio]{assets/shared.pdf}
\end{center}

\subsection{System Architectures}
System Architectures describe what software components are used, where to place each component, and how the components interact with each other. \\ \\
There are two types of system architectures:

\begin{itemize}
	\item \textbf{Centralised architectures}
	\item \textbf{Decentralised architectures}
\end{itemize}

\subsection{Centralised Architecture}
Centralised architectures follow the Client-Server model. The \textbf{server} implements some services, while the \textbf{client} requests services and waits for replies. \\ \\
The communication between server and client is \textbf{connectionless}. This means that it is highly efficient, but it is more complex to handle transmission failures (UDP). \\ \\
Server and client may also use another way to communicate. This protocol is connection-oriented, relatively low performance, but more reliable. This is because the node makes a request and receives a reply back in the same connection. \\ \\
Centralised architectures can be either \textbf{single-} or \textbf{multi-layered}. Multi-layered architectures enable to divide concerns, meaning that clients can contain only the program implementing the user-interface level (or only part of it). Moreover, architectures can also be \textbf{multi-tiered}.

\subsection{Decentralised Architectures}
Decentralised architectures can be either vertically or horizontally distributed.

\begin{itemize}
	\item \textbf{Vertical Distribution} \\
	It can be achieved by placing logically different components on different machines. An example of this is a three-tiered application.
	
	\item \textbf{Horizontal Distribution} \\
	Both clients and servers are physically split up into logically equivalent parts. Each part operates on its own share of the dataset. An example of this is a peer-to-peer system.
\end{itemize}

\subsubsection{Structured Peer-to-Peer Architectures}
Structured peer-to-peer architectures are deterministic procedures used to build an \textbf{overlay network}. Here nodes are processes, and links are possible communication channels. \\ \\
In the case of a structured peer-to-peer architecture, we use \textbf{Distributed Hash Tables} (DHT). These tables contain data items to which a random 128-bit key is assigned. Moreover, nodes are also assigned to a random key. \\ \\
An example of a structural peer-to-peer architecture is a \textbf{Chord}, which is depicted below.

\begin{center}
	\includegraphics[width=12cm, height=9.5cm, keepaspectratio]{assets/chord.pdf}
\end{center}

\subsubsection{Unstructured Peer-to-Peer Architectures}
In this type of architecture, the overlay network is built using a randomised procedure. Each node in the network has a list of neighbours, constructed in a random way. \\ \\
To find a data item inside of the network we need to flood it.

\begin{center}
	\includegraphics[width=8cm, height=5cm, keepaspectratio]{assets/unstructured.pdf}
\end{center}

\subsection{Superpeer}
Superpeers are special nodes that keep an index of data items. Other regular nodes join the network by connecting to one of the superpeers.

\begin{center}
	\includegraphics[width=9cm, height=10cm, keepaspectratio]{assets/superpeer.pdf}
\end{center}

\subsection{Middleware}
Middleware provides a degree of distribution transparency. They can either follow an object-based architectural style, or an event-based architectural style.

\subsubsection{Interceptors}
They offer a means to adapt the middleware. Interceptors break the usual flow of control and allow other application-specific code to be executed. Moreover, they are used to improve software management.

\subsubsection{Wrappers and Adapters}
Wrappers and adapters provide a similar interface to the original abstraction, and implement additional logic before or after invoking the original interface.

\subsubsection{Proxies and Stubs}
They provide -- as in the case of wrappers and adapters -- a similar interface as the original abstraction. However, in this case proxies and stubs usually own components rather than extending previously defined ones.

\section{Processes}
\subsection{Introduction}
Virtual processors are created by the OS. A process is a program executed on one of these virtual processors. Each processor has a process table in which several different values relative to the process are stored. \\ \\
Concurrent processes are protected from each other by making the sharing of CPU and hardware resources transparent and using special hardware. \\ \\
Every time a new process is created, the OS must create an independent address space as well. This is known as \textbf{context switching}, and it's really expensive.

\subsection{Threads}
A thread is a lightweight process that can run inside of a process. Threads share the same memory space. For this reason, context switching between threads is less expensive than between processes. \\ \\
Threads are used in distributed systems mainly for making communication calls non blocking. \\ \\
In the case of servers with \textbf{single-threaded models}, one thread receives the request and executes it rapidly. This is known as sequential processing. \\ \\
On the other hand, in the case of servers with \textbf{finite state machine models}, one thread executes the requests and the replies. Blocking system calls are replaced by non-blocking ones, and multiple requests can be handled in parallel.

\subsection{Virtualisation}
The role of virtualisation -- in distributed systems -- is to extend or replace existing interfaces and mimic the behaviour of other systems. \\ \\
The main reasons of virtualisation are the following:

\begin{itemize}
	\item Allow legacy software to run on new mainframe hardware
	\item Porting legacy interfaces to new platforms
	\item Isolating systems running on the same server
\end{itemize}

\subsection{Superservers}
A superserver is a kind of server that listens on many ports and fork a process to execute a service.

\subsection{Stateless vs Stateful Servers}
A server is said to be \textbf{stateless} if it does not keep any information about the state of the client. \\ \\
On the other hand, a server is said to be \textbf{stateful} if it maintains persistent information about the clients. This solution is better in terms of performance (it caches data of the users), but can be problematic in the case that the server crashes or experience other memory-related issues.

\subsection{Server Clusters}
A server cluster is a collection of machines connected through a network. Such clusters have three tiers:

\begin{enumerate}
	\item \textbf{Logical Switch} \\
	It receives client requests and route them to the servers.
	
	\item \textbf{Application Servers} \\
	Low-end servers are used when the storage is the bottleneck of the system. Otherwise, high-end servers are used when the service deals with computationally expensive computations.
	
	\item \textbf{Data-Processing Servers} \\
	The databases.
\end{enumerate}

\section{Communication}
In layered protocols, process \textit{A} con communicate with process \textit{B} by building a message in its address space. After doing so, a system call is used to send the message from \textit{A} to \textit{B}.



\end{document}



































